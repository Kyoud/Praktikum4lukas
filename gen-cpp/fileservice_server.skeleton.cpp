// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "fileservice.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <iostream>
#include <fstream>
#include <iterator>
#include <vector>

using std::ios;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

class fileserviceHandler : virtual public fileserviceIf {
 public:
  fileserviceHandler() {
	std::cout << "Server ready" << std::endl;
  }

  void download(FileChunk& _return, const std::string& fileName, const int64_t offset) {
	// Check if file exists on server
	if (std::ifstream("../server_files/" + fileName))
	{
		// Open the file
		std::ifstream file;
		file.open("../server_files/" + fileName);
		if(!file.is_open())
		return;

		// Get the length of the file
		file.seekg(0, ios::end);
		size_t fileSize = file.tellg();

		// Set cursor to current offset
		file.seekg(offset, ios::beg);

		// Create a vector to hold all the bytes in this file
		std::vector<char> data(fileSize, 0);

		// Read and copy file to data vector
		file.read(&data[0], fileSize);

		// Chunk Vector
		std::vector<char> chunkData;

		// Split byte vector in 100kByte chunks if big enough
		for(int i=0; i<fileSize-offset;i++){
			if((i%100000==0 && i!=0)){
				//std::cout << "Sending Chunk with Chunk Size: " << chunkData.size() << " Byte" << std::endl;
				_return.totalFileSize = fileSize;
				_return.newOffset = i;
				_return.data.insert(std::end(_return.data), std::begin(chunkData), std::end(chunkData));
				return;
			}
			// Add current character to Chunk Vector
			chunkData.push_back(data.at(i));
		}
		
		// Rest of file or file too small for chunks
		_return.totalFileSize = fileSize;
		_return.newOffset = 0;
		_return.data.insert(std::end(_return.data), std::begin(chunkData), std::end(chunkData));
		return;
	} else {
		std::cout << "Requested file does not exist" << std::endl;
	}
	return;
  }

  bool upload(const std::string& fileName, const int64_t currentOffset, const int64_t totalFilesize, const FileChunk& chunk) {
	// Your implementation goes here
	std::cout << "Upload for File: " << fileName << " totalFileSize: " << totalFilesize << std::endl;
	// Check if file exists on server
	if (std::ifstream("../server_files/" + fileName))
	{
		std::cout << "File exists on server" << std::endl;
		// Open the file
		std::ifstream file;
		file.open("../server_files/" + fileName);
		if(!file.is_open())
		return false;

		// Get the length of the file
		file.seekg(0, ios::end);
		size_t fileSize = file.tellg();

		// Compare file length
		if(fileSize >= totalFilesize) {
			// File is complete, upload can be stopped
			std::cout << "File is complete with size of " << fileSize << std::endl;
			return false;
		} else {
			// File is incomplete, continue upload
			std::cout << "File is incomplete with size of "<< fileSize << std::endl;
			// Chunk Vector
			std::vector<char> chunkData;
			// Add passed data to chunk Vector
			chunkData.insert(std::end(chunkData), std::begin(chunk.data), std::end(chunk.data));
			// Write chunk to file
			std::ofstream output_file("../server_files/"+fileName, ios::out | ios::app);
			std::ostream_iterator<char> output_iterator(output_file);
			std::copy(chunkData.begin(), chunkData.end(), output_iterator);
			return true;
		}
	} else {
		std::cout << "File doesn't exist on server. Creating it..." << std::endl;
		// Chunk Vector
		std::vector<char> chunkData;
		// Add passed data to chunk Vector
		chunkData.insert(std::end(chunkData), std::begin(chunk.data), std::end(chunk.data));
		// Write chunk to file
	        std::ofstream output_file("../server_files/"+fileName);
	        std::ostream_iterator<char> output_iterator(output_file);
	        std::copy(chunkData.begin(), chunkData.end(), output_iterator);

		return true;
	}

	return true;// this shouldn't happen, continue upload anyway
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<fileserviceHandler> handler(new fileserviceHandler());
  shared_ptr<TProcessor> processor(new fileserviceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

